" Enable nocompatible
if has('vim_starting')
    if &compatible
        set nocompatible
    endif
endif

"Detect OS
function! OSX()
    return has('macunix')
endfunction
function! LINUX()
    return has('unix') && !has('macunix') && !has('win32unix')
endfunction
function! WINDOWS()
    return (has('win16') || has('win32') || has('win64'))
endfunction

"Use English for anything in vim
if WINDOWS()
    silent exec 'language english'
elseif OSX()
    silent exec 'language en_US'
else
    let s:uname = system("uname -s")
    if s:uname == "Darwin\n"
        " in mac-terminal
        silent exec 'language en_US'
    else
        " in linux-terminal
        silent exec 'language en_US.utf8'
    endif
endif

" try to set encoding to utf-8
if WINDOWS()
    " Be nice and check for multi_byte even if the config requires
    " multi_byte support most of the time
    if has('multi_byte')
        " Windows cmd.exe still uses cp850. If Windows ever moved to
        " Powershell as the primary terminal, this would be utf-8
        set termencoding=cp850
        " Let Vim use utf-8 internally, because many scripts require this
        set encoding=utf-8
        setglobal fileencoding=utf-8
        " Windows has traditionally used cp1252, so it's probably wise to
        " fallback into cp1252 instead of eg. iso-8859-15.
        " Newer Windows files might contain utf-8 or utf-16 LE so we might
        " want to try them first.
        set fileencodings=ucs-bom,utf-8,utf-16le,cp1252,iso-8859-15
    endif

else
    " set default encoding to utf-8
    set encoding=utf-8
    set termencoding=utf-8
endif
scriptencoding utf-8

" Fsep && Psep
if WINDOWS()
    let s:Psep = ';'
    let s:Fsep = '\'
else
    let s:Psep = ':'
    let s:Fsep = '/'
endif

" Enable 256 colors
if $COLORTERM == 'gnome-terminal'
    set t_Co=256
endif

"Vim settings
let g:settings                         = {}
let g:settings.default_indent          = 2
let g:settings.max_column              = 120
let g:settings.auto_download_neobundle = 0
let g:settings.neobundle_installed     = 0
let g:settings.dein_installed     = 0
let g:settings.vim_plug_installed     = 0
let g:settings.plugin_bundle_dir       = join(['~/.cache','vimfiles',''],s:Fsep)
let g:settings.autocomplete_method     = ''
let g:settings.enable_cursorcolumn     = 0
let g:settings.enable_neomake          = 0
let g:settings.enable_ycm              = 0
let g:settings.enable_neocomplcache    = 0
let g:settings.enable_cursorline       = 0
let g:settings.use_colorscheme         = 1
let g:settings.vim_help_language       = 'en'
let g:settings.colorscheme             = 'gruvbox'
let g:settings.colorscheme_default     = 'desert'
let g:settings.filemanager             = 'vimfiler'
let g:settings.plugin_manager          = 'neobundle'  " neobundle or dein or vim-plug
let g:settings.plugin_groups_exclude   = []
let g:Vimrc_Home                       = fnamemodify(expand('<sfile>'), ':p:h:gs?\\?'. s:Fsep. '?')

fu! s:source_script(path)
    execute 'source ' . g:Vimrc_Home . s:Fsep . a:path
endf


"core vimrc
let g:settings.plugin_groups = []
call add(g:settings.plugin_groups, 'web')
call add(g:settings.plugin_groups, 'javascript')
call add(g:settings.plugin_groups, 'ruby')
call add(g:settings.plugin_groups, 'python')
call add(g:settings.plugin_groups, 'scala')
call add(g:settings.plugin_groups, 'go')
call add(g:settings.plugin_groups, 'scm')
call add(g:settings.plugin_groups, 'editing')
call add(g:settings.plugin_groups, 'indents')
call add(g:settings.plugin_groups, 'navigation')
call add(g:settings.plugin_groups, 'misc')

call add(g:settings.plugin_groups, 'core')
call add(g:settings.plugin_groups, 'unite')
call add(g:settings.plugin_groups, 'ctrlp')
call add(g:settings.plugin_groups, 'autocomplete')
if ! has('nvim')
    call add(g:settings.plugin_groups, 'vim')
else
    call add(g:settings.plugin_groups, 'nvim')
endif


if g:settings.vim_help_language == 'cn'
    call add(g:settings.plugin_groups, 'chinese')
endif
if g:settings.use_colorscheme==1
    call add(g:settings.plugin_groups, 'colorscheme')
endif
if OSX()
    call add(g:settings.plugin_groups, 'osx')
endif
if WINDOWS()
    call add(g:settings.plugin_groups, 'windows')
endif
if LINUX()
    call add(g:settings.plugin_groups, 'linux')
endif

if has('nvim')
    let g:settings.autocomplete_method = 'deoplete'
elseif has('lua')
    let g:settings.autocomplete_method = 'neocomplete'
else
    let g:settings.autocomplete_method = 'neocomplcache'
endif
if g:settings.enable_ycm
    let g:settings.autocomplete_method = 'ycm'
endif
if g:settings.enable_neocomplcache
    let g:settings.autocomplete_method = 'neocomplcache'
endif

for s:group in g:settings.plugin_groups_exclude
    let s:i = index(g:settings.plugin_groups, s:group)
    if s:i != -1
        call remove(g:settings.plugin_groups, s:i)
    endif
endfor

" python host for neovim
let g:python_host_prog = '/usr/bin/python'
let g:python3_host_prog = '/usr/bin/python3'

" auto install plugin manager
if g:settings.plugin_manager == 'neobundle'
    "auto install neobundle
    if filereadable(expand(g:settings.plugin_bundle_dir) . 'neobundle.vim'. s:Fsep. 'README.md')
        let g:settings.neobundle_installed = 1
    else
        if executable('git')
            exec '!git clone https://github.com/Shougo/neobundle.vim ' . g:settings.plugin_bundle_dir . 'neobundle.vim'
            let g:settings.neobundle_installed = 1
        else
            echohl WarningMsg | echom "You need install git!" | echohl None
        endif
    endif
    exec 'set runtimepath+='.g:settings.plugin_bundle_dir . 'neobundle.vim'
elseif g:settings.plugin_manager == 'dein'
    "auto install dein
    if filereadable(expand(g:settings.plugin_bundle_dir) . 'dein.vim'. s:Fsep. 'README.md')
        let g:settings.dein_installed = 1
    else
        if executable('git')
            exec '!git clone https://github.com/Shougo/dein.vim ' . g:settings.plugin_bundle_dir . 'dein.vim'
            let g:settings.dein_installed = 1
        else
            echohl WarningMsg | echom "You need install git!" | echohl None
        endif
    endif
    exec 'set runtimepath+='.g:settings.plugin_bundle_dir . 'dein.vim'
elseif g:settings.plugin_manager == 'vim-plug'
    "auto install vim-plug
    if filereadable(expand('~/.cache/vim-plug/autoload/plug.vim'))
        let g:settings.dein_installed = 1
    else
        if executable('curl')
            exec '!curl -fLo ~/.cache/vim-plug/autoload/plug.vim --create-dirs '
                        \. 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
            let g:settings.dein_installed = 1
        else
            echohl WarningMsg | echom "You need install curl!" | echohl None
        endif
    endif
    exec 'set runtimepath+=~/.cache/vim-plug/'
endif

"init manager func

fu! s:begin(path)
    if g:settings.plugin_manager == 'neobundle'
        call neobundle#begin(a:path)
    elseif g:settings.plugin_manager == 'dein'
        call dein#begin(a:path)
    elseif g:settings.plugin_manager == 'vim-plug'
        call plug#begin(a:path)
    endif
endf

fu! s:end()
    if g:settings.plugin_manager == 'neobundle'
        call neobundle#end()
        NeoBundleCheck
    elseif g:settings.plugin_manager == 'dein'
        call dein#end()
    elseif g:settings.plugin_manager == 'vim-plug'
        call plug#end()
    endif
endf

fu! s:parser(args)
endf

fu! s:add(repo,...)
    if g:settings.plugin_manager == 'neobundle'
        exec 'NeoBundle "'.a:repo.'"'.','.join(a:000,',')
    elseif g:settings.plugin_manager == 'dein'
        call dein#add(a:repo)
    endif
endf

fu! s:lazyadd(repo,...)
    if g:settings.plugin_manager == 'neobundle'
        exec 'NeoBundleLazy "'.a:repo.'"'.','.join(a:000,',')
    elseif g:settings.plugin_manager == 'dein'
        call dein#add(a:repo)
    endif
endf
fu! s:tap(plugin)
    if g:settings.plugin_manager == 'neobundle'
        return neobundle#tap(a:plugin)
    elseif g:settings.plugin_manager == 'dein'
        return dein#tap(a:plugin)
    endif
endf
fu! s:get_hooks(plugin)
    if g:settings.plugin_manager == 'neobundle'
        return neobundle#get_hooks(a:plugin)
    elseif g:settings.plugin_manager == 'dein'
        return dein#get_hooks(a:plugin)
    endif
endf
fu! s:fetch()
    if g:settings.plugin_manager == 'neobundle'
        NeoBundleFetch 'Shougo/neobundle.vim'
    elseif g:settings.plugin_manager == 'dein'
        call dein#add('Shougo/dein.vim', {'rtp': ''})
    endif
endf

fu! s:enable_plug()
    return g:settings.neobundle_installed || g:settings.dein_installed || (g:settings.vim_plug_installed && 0)
endf

"plugins and config
if s:enable_plug()
    call s:begin(g:settings.plugin_bundle_dir)
    call s:fetch()
    if count(g:settings.plugin_groups, 'core') "{{{
        call s:add('Shougo/vimproc.vim', {
                    \ 'build'   : {
                    \ 'windows' : 'tools\\update-dll-mingw',
                    \ 'cygwin'  : 'make -f make_cygwin.mak',
                    \ 'mac'     : 'make -f make_mac.mak',
                    \ 'linux'   : 'make',
                    \ 'unix'    : 'gmake',
                    \ },
                    \ })
    endif
    if count(g:settings.plugin_groups, 'unite') "{{{
        call s:add('Shougo/unite.vim')
        if s:tap('unite.vim')
            let s:hooks = s:get_hooks('unite.vim')
            func! s:hooks.on_source(bundle) abort
                call unite#custom#source('codesearch', 'max_candidates', 30)
                call unite#filters#matcher_default#use(['matcher_fuzzy'])
                call unite#filters#sorter_default#use(['sorter_rank'])
                call unite#custom#profile('default', 'context', {
                            \   'safe': 0,
                            \   'start_insert': 1,
                            \   'short_source_names': 1,
                            \   'update_time': 500,
                            \   'direction': 'rightbelow',
                            \   'winwidth': 40,
                            \   'winheight': 15,
                            \   'max_candidates': 100,
                            \   'no_auto_resize': 1,
                            \   'vertical_preview': 1,
                            \   'cursor_line_time': '0.10',
                            \   'hide_icon': 0,
                            \   'candidate-icon': ' ',
                            \   'marked_icon': '✓',
                            \   'prompt' : '⮀ '
                            \ })
                call unite#custom#profile('source/neobundle/update', 'context', {
                            \   'start_insert' : 0,
                            \ })
                let g:unite_source_codesearch_ignore_case = 1
                let g:unite_source_file_mru_time_format = "%m/%d %T "
                let g:unite_source_directory_mru_limit = 80
                let g:unite_source_directory_mru_time_format = "%m/%d %T "
                let g:unite_source_file_rec_max_depth = 6
                let g:unite_enable_ignore_case = 1
                let g:unite_enable_smart_case = 1
                let g:unite_data_directory='~/.cache/unite'
                "let g:unite_enable_start_insert=1
                let g:unite_source_history_yank_enable=1
                let g:unite_prompt='>> '
                let g:unite_split_rule = 'botright'
                let g:unite_winheight=25
                let g:unite_source_grep_default_opts = "-iRHn"
                            \ . " --exclude='tags'"
                            \ . " --exclude='cscope*'"
                            \ . " --exclude='*.svn*'"
                            \ . " --exclude='*.log*'"
                            \ . " --exclude='*tmp*'"
                            \ . " --exclude-dir='**/tmp'"
                            \ . " --exclude-dir='CVS'"
                            \ . " --exclude-dir='.svn'"
                            \ . " --exclude-dir='.git'"
                            \ . " --exclude-dir='node_modules'"
                let g:unite_launch_apps = [
                            \ 'rake',
                            \ 'make',
                            \ 'git pull',
                            \ 'git push']
                let g:unite_source_menu_menus = {}
                let g:unite_source_menu_menus.git = {
                            \ 'description' : '            gestionar repositorios git
                            \                            ⌘ [espacio]g',
                            \}
                let g:unite_source_menu_menus.git.command_candidates = [
                            \['▷ tig                                                        ⌘ ,gt',
                            \'normal ,gt'],
                            \['▷ git status       (Fugitive)                                ⌘ ,gs',
                            \'Gstatus'],
                            \['▷ git diff         (Fugitive)                                ⌘ ,gd',
                            \'Gdiff'],
                            \['▷ git commit       (Fugitive)                                ⌘ ,gc',
                            \'Gcommit'],
                            \['▷ git log          (Fugitive)                                ⌘ ,gl',
                            \'exe "silent Glog | Unite quickfix"'],
                            \['▷ git blame        (Fugitive)                                ⌘ ,gb',
                            \'Gblame'],
                            \['▷ git stage        (Fugitive)                                ⌘ ,gw',
                            \'Gwrite'],
                            \['▷ git checkout     (Fugitive)                                ⌘ ,go',
                            \'Gread'],
                            \['▷ git rm           (Fugitive)                                ⌘ ,gr',
                            \'Gremove'],
                            \['▷ git mv           (Fugitive)                                ⌘ ,gm',
                            \'exe "Gmove " input("destino: ")'],
                            \['▷ git push         (Fugitive, salida por buffer)             ⌘ ,gp',
                            \'Git! push'],
                            \['▷ git pull         (Fugitive, salida por buffer)             ⌘ ,gP',
                            \'Git! pull'],
                            \['▷ git prompt       (Fugitive, salida por buffer)             ⌘ ,gi',
                            \'exe "Git! " input("comando git: ")'],
                            \['▷ git cd           (Fugitive)',
                            \'Gcd'],
                            \]
                let g:unite_source_grep_max_candidates = 200
                if executable('hw')
                    " Use hw (highway)
                    " https://github.com/tkengo/highway
                    let g:unite_source_grep_command = 'hw'
                    let g:unite_source_grep_default_opts = '--no-group --no-color'
                    let g:unite_source_grep_recursive_opt = ''
                elseif executable('ag')
                    " Use ag (the silver searcher)
                    " https://github.com/ggreer/the_silver_searcher
                    let g:unite_source_grep_command = 'ag'
                    let g:unite_source_grep_default_opts =
                                \ '-i --line-numbers --nocolor --nogroup --hidden --ignore ' .
                                \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
                    let g:unite_source_grep_recursive_opt = ''
                elseif executable('pt')
                    " Use pt (the platinum searcher)
                    " https://github.com/monochromegane/the_platinum_searcher
                    let g:unite_source_grep_command = 'pt'
                    let g:unite_source_grep_default_opts = '--nogroup --nocolor'
                    let g:unite_source_grep_recursive_opt = ''
                elseif executable('ack-grep')
                    " Use ack
                    " http://beyondgrep.com/
                    let g:unite_source_grep_command = 'ack-grep'
                    let g:unite_source_grep_default_opts =
                                \ '-i --no-heading --no-color -k -H'
                    let g:unite_source_grep_recursive_opt = ''
                elseif executable('ack')
                    let g:unite_source_grep_command = 'ack'
                    let g:unite_source_grep_default_opts = '-i --no-heading --no-color -k -H'
                    let g:unite_source_grep_recursive_opt = ''
                elseif executable('jvgrep')
                    " Use jvgrep
                    " https://github.com/mattn/jvgrep
                    let g:unite_source_grep_command = 'jvgrep'
                    let g:unite_source_grep_default_opts = '-i --exclude ''\.(git|svn|hg|bzr)'''
                    let g:unite_source_grep_recursive_opt = '-R'
                endif
                let g:unite_source_rec_async_command =
                            \ ['ag', '--follow', '--nocolor', '--nogroup',
                            \  '--hidden', '-g', '']
                nnoremap <silent><leader>ufa :<C-u>Unite -no-split -buffer-name=Mixed -start-insert file file_mru file_rec buffer<cr>
                nnoremap <silent><leader>ufr :<C-u>Unite -buffer-name=files file_rec/async:!<cr>
                nnoremap <silent><leader>ufg :<C-u>Unite -buffer-name=git-repo file_rec/git<cr>
                call unite#custom#profile('file_rec/async,file_rec/git', 'context', {
                            \   'start_insert' : 1,
                            \   'quit'         : 1,
                            \   'split'        : 1,
                            \   'keep_focus'   : 1,
                            \   'winheight'    : 20,
                            \ })
                call unite#custom#source('file_rec/async', 'ignore_globs',['*.png','.git/','*.ttf'])
                nnoremap <silent><leader>uf  :<C-u>Unite -no-split -buffer-name=files -start-insert file<cr>
                nnoremap <silent><leader>ufm :<C-u>Unite -no-split -buffer-name=mru   -start-insert file_mru<cr>
                nnoremap <silent><leader>ubf :<C-u>Unite -buffer-name=buffer  buffer<cr>
                nnoremap <silent><leader>utb :<C-u>Unite -buffer-name=buffer_tab  buffer_tab<cr>
                call unite#custom#profile('buffer,buffer_tab', 'context', {
                            \   'start_insert' : 0,
                            \   'quit'         : 1,
                            \   'keep_focus'   : 1,
                            \   'winheight'    : 20,
                            \ })
                nnoremap <silent><leader>um  :<C-u>Unite -start-insert mapping<CR>
                nnoremap <C-h>  :<C-u>Unite -start-insert help<CR>
                nnoremap <silent> g<C-h>  :<C-u>UniteWithCursorWord help<CR>
                "" Tag search
                """ For searching the word in the cursor in tag file
                nnoremap <silent><leader>f :<c-u>Unite tag/include:<C-R><C-w><CR>
                nnoremap <silent><leader>ff :<c-u>Unite tag/include -start-insert<CR>
                "" grep dictionay
                """ For searching the word in the cursor in the current directory
                nnoremap <silent><leader>v :Unite -auto-preview -no-split grep:.::<C-R><C-w><CR>
                nnoremap <space>/ :Unite -auto-preview grep:.<cr>
                """ For searching the word handin
                nnoremap <silent><leader>vs :Unite -auto-preview -no-split grep:.<CR>
                """ For searching the word in the cursor in the current buffer
                noremap <silent><leader>vf :Unite -auto-preview -no-split grep:%::<C-r><C-w><CR>
                """ For searching the word in the cursor in all opened buffer
                noremap <silent><leader>va :Unite -auto-preview -no-split grep:$buffers::<C-r><C-w><CR>
                nnoremap <silent> <C-b> :<C-u>Unite -start-insert -buffer-name=buffer buffer<cr>
                "" outline
                nnoremap <silent><leader>o :<C-u>Unite -buffer-name=outline -start-insert -auto-preview -no-split outline<cr>
                "" Line search
                nnoremap <silent><leader>l :Unite line -start-insert  -auto-preview -no-split<CR>
                "" Yank history
                nnoremap <silent><leader>y :<C-u>Unite -no-split -buffer-name=yank history/yank<cr>
                " search plugin
                " :Unite neobundle/search
                "for Unite menu{
                nnoremap <silent><leader>ug :Unite -silent -start-insert menu:git<CR>
                " The prefix key.
                nnoremap    [unite]   <Nop>
                nmap    f [unite]
                nnoremap <silent> [unite]c  :<C-u>UniteWithCurrentDir
                            \ -buffer-name=files buffer bookmark file<CR>
                nnoremap <silent> [unite]b  :<C-u>UniteWithBufferDir
                            \ -buffer-name=files -prompt=%\  buffer bookmark file<CR>
                nnoremap <silent> [unite]r  :<C-u>Unite
                            \ -buffer-name=register register<CR>
                nnoremap <silent> [unite]o  :<C-u>Unite outline<CR>
                nnoremap <silent> [unite]s  :<C-u>Unite session<CR>
                nnoremap <silent> [unite]n  :<C-u>Unite session/new<CR>
                nnoremap <silent> [unite]fr
                            \ :<C-u>Unite -buffer-name=resume resume<CR>
                nnoremap <silent> [unite]ma
                            \ :<C-u>Unite mapping<CR>
                nnoremap <silent> [unite]me
                            \ :<C-u>Unite output:message<CR>
                nnoremap  [unite]f  :<C-u>Unite source<CR>
                nnoremap <silent> [unite]w
                            \ :<C-u>Unite -buffer-name=files -no-split
                            \ jump_point file_point buffer_tab
                            \ file_rec:! file file/new<CR>
            endf
        endif
        call s:add('Shougo/neoyank.vim')
        call s:add('soh335/unite-qflist')
        call s:add('ujihisa/unite-equery')
        call s:add('m2mdas/unite-file-vcs')
        call s:add('Shougo/neomru.vim')
        call s:add('kmnk/vim-unite-svn')
        call s:add('basyura/unite-rails')
        call s:add('nobeans/unite-grails')
        call s:add('choplin/unite-vim_hacks')
        call s:add('mattn/webapi-vim')
        call s:add('mattn/wwwrenderer-vim')
        call s:add('thinca/vim-openbuf')
        call s:add('ujihisa/unite-haskellimport')
        call s:add('oppara/vim-unite-cake')
        call s:add('thinca/vim-ref')
        if s:tap('vim-ref')
            let s:hooks = s:get_hooks('vim-ref')
            func! s:hooks.on_source(bundle) abort
                let g:ref_source_webdict_sites = {
                            \   'je': {
                            \     'url': 'http://dictionary.infoseek.ne.jp/jeword/%s',
                            \   },
                            \   'ej': {
                            \     'url': 'http://dictionary.infoseek.ne.jp/ejword/%s',
                            \   },
                            \   'wiki': {
                            \     'url': 'http://ja.wikipedia.org/wiki/%s',
                            \   },
                            \   'cn': {
                            \     'url': 'http://www.iciba.com/%s',
                            \   },
                            \   'wikipedia:en':{'url': 'http://en.wikipedia.org/wiki/%s',  },
                            \   'bing':{'url': 'http://cn.bing.com/search?q=%s', },
                            \ }
                let g:ref_source_webdict_sites.default = 'cn'
                "let g:ref_source_webdict_cmd='lynx -dump -nonumbers %s'
                "let g:ref_source_webdict_cmd='w3m -dump %s'
                "The filter on the output. Remove the first few lines
                function! g:ref_source_webdict_sites.je.filter(output)
                    return join(split(a:output, "\n")[15 :], "\n")
                endfunction
                function! g:ref_source_webdict_sites.ej.filter(output)
                    return join(split(a:output, "\n")[15 :], "\n")
                endfunction
                function! g:ref_source_webdict_sites.wiki.filter(output)
                    return join(split(a:output, "\n")[17 :], "\n")
                endfunction
                nnoremap <Leader>rj :<C-u>Ref webdict je<Space>
                nnoremap <Leader>re :<C-u>Ref webdict ej<Space>
                nnoremap <Leader>rc :<C-u>Ref webdict cn<Space>
                nnoremap <Leader>rw :<C-u>Ref webdict wikipedia:en<Space>
                nnoremap <Leader>rb :<C-u>Ref webdict bing<Space>
            endf
        endif
        call s:add('heavenshell/unite-zf')
        call s:add('heavenshell/unite-sf2')
        call s:add('Shougo/unite-outline')
        call s:add('hewes/unite-gtags')
        if s:tap('unite-gtags')
            let s:hooks = s:get_hooks('unite-gtags')
            func! s:hooks.on_source(bundle) abort
                nnoremap <leader>gd :execute 'Unite  -auto-preview -start-insert -no-split gtags/def:'.expand('<cword>')<CR>
                nnoremap <leader>gc :execute 'Unite  -auto-preview -start-insert -no-split gtags/context'<CR>
                nnoremap <leader>gr :execute 'Unite  -auto-preview -start-insert -no-split gtags/ref'<CR>
                nnoremap <leader>gg :execute 'Unite  -auto-preview -start-insert -no-split gtags/grep'<CR>
                nnoremap <leader>gp :execute 'Unite  -auto-preview -start-insert -no-split gtags/completion'<CR>
                vnoremap <leader>gd <ESC>:execute 'Unite -auto-preview -start-insert -no-split gtags/def:'.GetVisualSelection()<CR>
                let g:unite_source_gtags_project_config = {
                            \ '_':                   { 'treelize': 0 }
                            \ }
            endf
        endif
        call s:add('rafi/vim-unite-issue')
        call s:add('tsukkee/unite-tag')
        call s:add('ujihisa/unite-launch')
        call s:add('ujihisa/unite-gem')
        call s:add('osyo-manga/unite-filetype')
        call s:add('thinca/vim-unite-history')
        call s:add('Shougo/neobundle-vim-recipes')
        call s:add('Shougo/unite-help')
        call s:add('ujihisa/unite-locate')
        call s:add('kmnk/vim-unite-giti')
        call s:add('ujihisa/unite-font')
        call s:add('t9md/vim-unite-ack')
        call s:add('mileszs/ack.vim')
        call s:add('albfan/ag.vim')
        let g:ag_prg="ag  --vimgrep"
        let g:ag_working_path_mode="r"
        call s:add('dyng/ctrlsf.vim')
        if s:tap('ctrlsf.vim')
            let s:hooks = s:get_hooks('ctrlsf.vim')
            func! s:hooks.on_source(bundle) abort
                nmap <leader>sf <Plug>CtrlSFPrompt
                vmap <leader>sf <Plug>CtrlSFVwordPath
                vmap <leader>sF <Plug>CtrlSFVwordExec
                nmap <leader>sn <Plug>CtrlSFCwordPath
                nmap <leader>sp <Plug>CtrlSFPwordPath
                nnoremap <leader>so :CtrlSFOpen<CR>
                nnoremap <leader>st :CtrlSFToggle<CR>
                inoremap <leader>st <Esc>:CtrlSFToggle<CR>
            endf
        endif
        call s:add('daisuzu/unite-adb')
        call s:add('osyo-manga/unite-airline_themes')
        call s:add('mattn/unite-vim_advent-calendar')
        call s:add('mattn/unite-remotefile')
        call s:add('sgur/unite-everything')
        call s:add('kannokanno/unite-dwm')
        call s:add('raw1z/unite-projects')
        call s:add('voi/unite-ctags')
        call s:add('Shougo/unite-session')
        call s:add('osyo-manga/unite-quickfix')
        call s:add('Shougo/vimfiler')
        if s:tap('vimfiler')
            let s:hooks = s:get_hooks("vimfiler")
            function! s:hooks.on_source(bundle) abort
                let g:vimfiler_as_default_explorer = 1
                let g:vimfiler_restore_alternate_file = 1
                let g:vimfiler_tree_indentation = 1
                let g:vimfiler_tree_leaf_icon = ''
                let g:vimfiler_tree_opened_icon = '▼'
                if WINDOWS()
                    let g:vimfiler_tree_closed_icon = '>'
                else
                    let g:vimfiler_tree_closed_icon = '▷'

                endif
                let g:vimfiler_file_icon = ''
                let g:vimfiler_readonly_file_icon = '*'
                let g:vimfiler_marked_file_icon = '√'
                "let g:vimfiler_preview_action = 'auto_preview'
                let g:vimfiler_ignore_pattern =
                            \ '^\%(\.git\|\.idea\|\.DS_Store\|\.vagrant\|.stversions'
                            \ .'\|node_modules\|.*\.pyc\)$'

                if has('mac')
                    let g:vimfiler_quick_look_command =
                                \ '/Applications//Sublime\ Text.app/Contents/MacOS/Sublime\ Text'
                else
                    let g:vimfiler_quick_look_command = 'gloobus-preview'
                endif

                call vimfiler#custom#profile('default', 'context', {
                            \ 'explorer' : 1,
                            \ 'winwidth' : 30,
                            \ 'winminwidth' : 30,
                            \ 'toggle' : 1,
                            \ 'columns' : 'type',
                            \ 'auto_expand': 1,
                            \ 'direction' : 'rightbelow',
                            \ 'parent': 0,
                            \ 'explorer_columns' : 'type',
                            \ 'status' : 1,
                            \ 'safe' : 0,
                            \ 'split' : 1,
                            \ 'hidden': 1,
                            \ 'no_quit' : 1,
                            \ 'force_hide' : 0,
                            \ })
                autocmd FileType vimfiler call s:vimfilerinit()
                "autocmd VimEnter * if !argc() | VimFiler | endif
                autocmd BufEnter * if (winnr('$') == 1 && &filetype ==# 'vimfiler') |
                            \ q | endif
                function! s:vimfilerinit()
                    set nonumber
                    set norelativenumber
                endf
            endfunction
        endif
        "NeoBundle 'mattn/webapi-vim'
        "NeoBundle 'mattn/googlesuggest-complete-vim'
        "NeoBundle 'mopp/googlesuggest-source.vim'
        call s:add('ujihisa/unite-colorscheme')
        call s:add('mattn/unite-gist')
        "NeoBundle 'klen/unite-radio.vim'
        call s:add('tacroe/unite-mark')
        call s:add('tacroe/unite-alias')
        call s:add('ujihisa/quicklearn')
        call s:add('tex/vim-unite-id')
        call s:add('sgur/unite-qf')
        call s:lazyadd('lambdalisue/unite-grep-vcs', {
                    \ 'autoload': {
                    \    'unite_sources': ['grep/git', 'grep/hg'],
                    \}})
    endif "}}}


    "{{{ctrlpvim settings
    if count(g:settings.plugin_groups, 'ctrlp') "{{{

        call s:add('ctrlpvim/ctrlp.vim')
        call s:add('felixSchl/ctrlp-unity3d-docs')
        call s:add('voronkovich/ctrlp-nerdtree.vim')
        call s:add('elentok/ctrlp-objects.vim')
        call s:add('h14i/vim-ctrlp-buftab')
        call s:add('vim-scripts/ctrlp-cmdpalette')
        call s:add('mattn/ctrlp-windowselector')
        call s:add('the9ball/ctrlp-gtags')
        call s:add('thiderman/ctrlp-project')
        call s:add('mattn/ctrlp-google')
        call s:add('ompugao/ctrlp-history')
        call s:add('pielgrzym/ctrlp-sessions')
        call s:add('tacahiroy/ctrlp-funky')
        call s:add('brookhong/k.vim')
        call s:add('mattn/ctrlp-launcher')
        call s:add('sgur/ctrlp-extensions.vim')
        call s:add('FelikZ/ctrlp-py-matcher')
        call s:add('JazzCore/ctrlp-cmatcher')
        call s:add('ompugao/ctrlp-z')
        let g:ctrlp_map = '<c-p>'
        let g:ctrlp_cmd = 'CtrlP'
        let g:ctrlp_working_path_mode = 'ra'
        let g:ctrlp_root_markers = 'pom.xml'
        let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:25,results:25'
        let g:ctrlp_show_hidden = 1
        "for caching
        let g:ctrlp_use_caching = 1
        let g:ctrlp_clear_cache_on_exit = 0
        let g:ctrlp_cache_dir = $HOME.'/.cache/ctrlp'
        "let g:ctrlp_map = ',,'
        "let g:ctrlp_open_multiple_files = 'v'
        let g:ctrlp_custom_ignore = {
                    \ 'dir':  '\v[\/]\.(git|hg|svn)$|target',
                    \ 'file': '\v\.(exe|so|dll|ttf|png)$',
                    \ 'link': 'some_bad_symbolic_links',
                    \ }
        let g:ctrlp_user_command = ['ag %s -i --nocolor --nogroup --hidden
                    \ --ignore out
                    \ --ignore .git
                    \ --ignore .svn
                    \ --ignore .hg
                    \ --ignore .DS_Store
                    \ --ignore "**/*.pyc"
                    \ -g ""'
                    \ ]

        let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch'  }


        "nnoremap <Leader>kk :CtrlPMixed<Cr>


        " comment for ctrlp-funky {{{
        nnoremap <Leader>fu :CtrlPFunky<Cr>
        " narrow the list down with a word under cursor
        nnoremap <Leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<Cr>
        let g:ctrlp_funky_syntax_highlight = 1
        " }}}

        "for ctrlp_nerdtree {{{
        let g:ctrlp_nerdtree_show_hidden = 1
        "}}}

        "for ctrlp_sessions{{{
        let g:ctrlp_extensions = ['funky', 'sessions' , 'k' , 'tag', 'mixed', 'quickfix', 'undo', 'line', 'changes', 'cmdline', 'menu']
        "}}}


        "for k.vim {{{
        nnoremap <silent> <leader>qe :CtrlPK<CR>
        "}}}

        " for ctrlp-launcher {{{
        nnoremap <Leader>pl :<c-u>CtrlPLauncher<cr>
        "}}}

        ""for ctrlp-cmatcher {{{

        "let g:ctrlp_max_files = 0
        "let g:ctrlp_match_func = {'match' : 'matcher#cmatch' }

        ""}}}

    endif "}}}


    if count(g:settings.plugin_groups, 'autocomplete') "{{{
        call s:add('honza/vim-snippets')
        imap <silent><expr><TAB> MyTabfunc()
        smap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
        inoremap <silent> <CR> <C-r>=MyEnterfunc()<Cr>
        inoremap <silent> <Leader><Tab> <C-r>=MyLeaderTabfunc()<CR>
        inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
        inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
        inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<PageDown>"
        inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<PageUp>"
        if g:settings.autocomplete_method == 'ycm' "{{{
            call s:add('SirVer/ultisnips')
            let g:UltiSnipsExpandTrigger="<tab>"
            let g:UltiSnipsJumpForwardTrigger="<tab>"
            let g:UltiSnipsJumpBackwardTrigger="<S-tab>"
            let g:UltiSnipsSnippetsDir='~/DotFiles/snippets'
            call s:add('ervandew/supertab')
            let g:SuperTabContextDefaultCompletionType = "<c-n>"
            let g:SuperTabDefaultCompletionType = '<C-n>'
            autocmd InsertLeave * if pumvisible() == 0|pclose|endif
            let g:neobundle#install_process_timeout = 1500
            call s:add('Valloric/YouCompleteMe')
            "let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
            "let g:ycm_confirm_extra_conf = 0
            let g:ycm_collect_identifiers_from_tags_files = 1
            let g:ycm_collect_identifiers_from_comments_and_strings = 1
            let g:ycm_key_list_select_completion = ['<C-TAB>', '<Down>']
            let g:ycm_key_list_previous_completion = ['<C-S-TAB>','<Up>']
            let g:ycm_seed_identifiers_with_syntax = 1
            let g:ycm_key_invoke_completion = '<leader><tab>'
            let g:ycm_semantic_triggers =  {
                        \   'c' : ['->', '.'],
                        \   'objc' : ['->', '.'],
                        \   'ocaml' : ['.', '#'],
                        \   'cpp,objcpp' : ['->', '.', '::'],
                        \   'perl' : ['->'],
                        \   'php' : ['->', '::'],
                        \   'cs,javascript,d,python,perl6,scala,vb,elixir,go' : ['.'],
                        \   'java,jsp' : ['.'],
                        \   'vim' : ['re![_a-zA-Z]+[_\w]*\.'],
                        \   'ruby' : ['.', '::'],
                        \   'lua' : ['.', ':'],
                        \   'erlang' : [':'],
                        \ }
        elseif g:settings.autocomplete_method == 'neocomplete' "{{{
            call s:add('Shougo/neocomplete')
            if s:tap('neocomplete')
                let s:hooks = s:get_hooks("neocomplete")
                function! s:hooks.on_source(bundle) abort
                    let g:neocomplete#data_directory='~/.cache/neocomplete'
                    let g:acp_enableAtStartup = 0
                    let g:neocomplete#enable_at_startup = 1
                    " Use smartcase.
                    let g:neocomplete#enable_smart_case = 1
                    let g:neocomplete#enable_camel_case = 1
                    "let g:neocomplete#enable_ignore_case = 1
                    let g:neocomplete#enable_fuzzy_completion = 1
                    " Set minimum syntax keyword length.
                    let g:neocomplete#sources#syntax#min_keyword_length = 3
                    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

                    " Define dictionary.
                    let g:neocomplete#sources#dictionary#dictionaries = {
                                \ 'default' : '',
                                \ 'vimshell' : $CACHE.'/vimshell/command-history',
                                \ 'java' : '~/.vim/dict/java.dict',
                                \ 'ruby' : '~/.vim/dict/ruby.dict',
                                \ 'scala' : '~/.vim/dict/scala.dict',
                                \ }

                    let g:neocomplete#enable_auto_delimiter = 1

                    " Define keyword.
                    if !exists('g:neocomplete#keyword_patterns')
                        let g:neocomplete#keyword_patterns = {}
                    endif
                    let g:neocomplete#keyword_patterns._ = '\h\k*(\?'


                    " AutoComplPop like behavior.
                    let g:neocomplete#enable_auto_select = 0

                    if !exists('g:neocomplete#sources#omni#input_patterns')
                        let g:neocomplete#sources#omni#input_patterns = {}
                    endif

                    let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
                    let g:neocomplete#sources#omni#input_patterns.java ='[^. \t0-9]\.\w*'
                    let g:neocomplete#force_omni_input_patterns = {}
                    "let g:neocomplete#force_omni_input_patterns.java = '^\s*'
                    " <C-h>, <BS>: close popup and delete backword char.
                    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
                    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
                    inoremap <expr><C-y>  neocomplete#close_popup()
                    inoremap <expr><C-e>  neocomplete#cancel_popup()
                endfunction
            endif
        elseif g:settings.autocomplete_method == 'neocomplcache' "{{{
            call s:add('Shougo/neocomplcache.vim')
            if s:tap('neocomplcache.vim')
                let s:hooks = s:get_hooks("neocomplcache.vim")
                function! s:hooks.on_source(bundle) abort
                    "---------------------------------------------------------------------------
                    " neocomplache.vim
                    "
                    let g:neocomplcache_enable_at_startup = 1
                    " Use smartcase
                    let g:neocomplcache_enable_smart_case = 1
                    " Use camel case completion.
                    let g:neocomplcache_enable_camel_case_completion = 1
                    " Use underbar completion.
                    let g:neocomplcache_enable_underbar_completion = 1
                    " Use fuzzy completion.
                    let g:neocomplcache_enable_fuzzy_completion = 1

                    " Set minimum syntax keyword length.
                    let g:neocomplcache_min_syntax_length = 3
                    " Set auto completion length.
                    let g:neocomplcache_auto_completion_start_length = 2
                    " Set manual completion length.
                    let g:neocomplcache_manual_completion_start_length = 0
                    " Set minimum keyword length.
                    let g:neocomplcache_min_keyword_length = 3
                    " let g:neocomplcache_enable_cursor_hold_i = v:version > 703 ||
                    "       \ v:version == 703 && has('patch289')
                    let g:neocomplcache_enable_cursor_hold_i = 0
                    let g:neocomplcache_cursor_hold_i_time = 300
                    let g:neocomplcache_enable_insert_char_pre = 1
                    let g:neocomplcache_enable_prefetch = 1
                    let g:neocomplcache_skip_auto_completion_time = '0.6'

                    " For auto select.
                    let g:neocomplcache_enable_auto_select = 1

                    let g:neocomplcache_enable_auto_delimiter = 1
                    let g:neocomplcache_disable_auto_select_buffer_name_pattern =
                                \ '\[Command Line\]'
                    "let g:neocomplcache_disable_auto_complete = 0
                    let g:neocomplcache_max_list = 100
                    let g:neocomplcache_force_overwrite_completefunc = 1
                    if !exists('g:neocomplcache_omni_patterns')
                        let g:neocomplcache_omni_patterns = {}
                    endif
                    if !exists('g:neocomplcache_omni_functions')
                        let g:neocomplcache_omni_functions = {}
                    endif
                    if !exists('g:neocomplcache_force_omni_patterns')
                        let g:neocomplcache_force_omni_patterns = {}
                    endif
                    let g:neocomplcache_enable_auto_close_preview = 1
                    " let g:neocomplcache_force_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
                    let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
                    let g:neocomplcache_omni_patterns.java = '[^. *\t]\.\w*\|\h\w*::'
                    let g:neocomplcache_force_omni_patterns.java = '[^. *\t]\.\w*\|\h\w*::'

                    " For clang_complete.
                    let g:neocomplcache_force_overwrite_completefunc = 1
                    let g:neocomplcache_force_omni_patterns.c =
                                \ '[^.[:digit:] *\t]\%(\.\|->\)'
                    let g:neocomplcache_force_omni_patterns.cpp =
                                \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
                    let g:clang_complete_auto = 0
                    let g:clang_auto_select = 0
                    let g:clang_use_library   = 1

                    " Define keyword pattern.
                    if !exists('g:neocomplcache_keyword_patterns')
                        let g:neocomplcache_keyword_patterns = {}
                    endif
                    let g:neocomplcache_keyword_patterns['default'] = '[0-9a-zA-Z:#_]\+'
                    let g:neocomplcache_keyword_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
                    let g:neocomplete#enable_multibyte_completion = 1

                    let g:neocomplcache_vim_completefuncs = {
                                \ 'Ref' : 'ref#complete',
                                \ 'Unite' : 'unite#complete_source',
                                \ 'VimShellExecute' :
                                \      'vimshell#vimshell_execute_complete',
                                \ 'VimShellInteractive' :
                                \      'vimshell#vimshell_execute_complete',
                                \ 'VimShellTerminal' :
                                \      'vimshell#vimshell_execute_complete',
                                \ 'VimShell' : 'vimshell#complete',
                                \ 'VimFiler' : 'vimfiler#complete',
                                \ 'Vinarise' : 'vinarise#complete',
                                \}
                endf
            endif
        elseif g:settings.autocomplete_method == 'deoplete'
            call s:add('Shougo/deoplete.nvim')
            if s:tap('deoplete.nvim')
                let s:hooks = s:get_hooks("deoplete.nvim")
                function! s:hooks.on_source(bundle)
                    let g:deoplete#enable_at_startup = 1
                    let g:deoplete#enable_ignore_case = 1
                    let g:deoplete#enable_smart_case = 1
                    let g:deoplete#enable_refresh_always = 1
                    let g:deoplete#omni#input_patterns = get(g:,'deoplete#omni#input_patterns',{})
                    let g:deoplete#omni#input_patterns.java = [
                                \'[^. \t0-9]\.\w*',
                                \'[^. \t0-9]\->\w*',
                                \'[^. \t0-9]\::\w*',
                                \]
                    let g:deoplete#omni#input_patterns.jsp = ['[^. \t0-9]\.\w*']
                    let g:deoplete#ignore_sources = {}
                    let g:deoplete#ignore_sources._ = ['javacomplete2']
                    call deoplete#custom#set('_', 'matchers', ['matcher_full_fuzzy'])
                    inoremap <expr><C-h> deoplete#mappings#smart_close_popup()."\<C-h>"
                    inoremap <expr><BS> deoplete#mappings#smart_close_popup()."\<C-h>"
                endfunction
            endif
        endif "}}}
        call s:add('Shougo/neco-syntax')
        call s:add('ujihisa/neco-look')
        call s:add('Shougo/neco-vim')
        if !exists('g:necovim#complete_functions')
            let g:necovim#complete_functions = {}
        endif
        let g:necovim#complete_functions.Ref =
                    \ 'ref#complete'
        call s:add('Shougo/context_filetype.vim')
        call s:add('Shougo/neoinclude.vim')
        call s:add('Shougo/neosnippet-snippets')
        call s:add('Shougo/neosnippet.vim')
        if WINDOWS()
            let g:neosnippet#snippets_directory=g:Vimrc_Home .s:Fsep .'snippets'
        else
            let g:neosnippet#snippets_directory='~/DotFiles/snippets'
        endif
        let g:neosnippet#enable_snipmate_compatibility=1
        let g:neosnippet#enable_complete_done = 1
        let g:neosnippet#completed_pairs= {}
        let g:neosnippet#completed_pairs.java = {'(' : ')'}
        call s:add('Shougo/neopairs.vim')
        if g:neosnippet#enable_complete_done
            let g:neopairs#enable = 0
        endif
        imap <expr><S-TAB> pumvisible() ? "\<C-p>" : ""
        smap <expr><S-TAB> pumvisible() ? "\<C-p>" : ""
    endif "}}}

    if count(g:settings.plugin_groups, 'colorscheme') "{{{
        "colorscheme
        call s:add('morhetz/gruvbox')
        call s:add('mhartington/oceanic-next')
        call s:add('nanotech/jellybeans.vim')
        call s:add('altercation/vim-colors-solarized')
        call s:add('kristijanhusak/vim-hybrid-material')
    endif

    if count(g:settings.plugin_groups, 'chinese') "{{{
        call s:add('vimcn/vimcdoc')
    endif

    if count(g:settings.plugin_groups, 'vim') "{{{
        call s:add('Shougo/vimshell.vim')
    endif
    call s:add('tpope/vim-scriptease')
    call s:add('tpope/vim-fugitive')
    call s:add('tpope/vim-surround')
    call s:add('terryma/vim-multiple-cursors')
    let g:multi_cursor_next_key='<C-j>'
    let g:multi_cursor_prev_key='<C-k>'
    let g:multi_cursor_skip_key='<C-x>'
    let g:multi_cursor_quit_key='<Esc>'

    "web plugins

    call s:lazyadd('groenewege/vim-less', {'autoload':{'filetypes':['less']}})
    call s:lazyadd('cakebaker/scss-syntax.vim', {'autoload':{'filetypes':['scss','sass']}})
    call s:lazyadd('hail2u/vim-css3-syntax', {'autoload':{'filetypes':['css','scss','sass']}})
    call s:lazyadd('ap/vim-css-color', {'autoload':{'filetypes':['css','scss','sass','less','styl']}})
    call s:lazyadd('othree/html5.vim', {'autoload':{'filetypes':['html']}})
    call s:lazyadd('wavded/vim-stylus', {'autoload':{'filetypes':['styl']}})
    call s:lazyadd('digitaltoad/vim-jade', {'autoload':{'filetypes':['jade']}})
    call s:lazyadd('juvenn/mustache.vim', {'autoload':{'filetypes':['mustache']}})
    call s:add('Valloric/MatchTagAlways')
    "call s:lazyadd('marijnh/tern_for_vim', {
    "\ 'autoload': { 'filetypes': ['javascript'] },
    "\ 'build': {
    "\ 'mac': 'npm install',
    "\ 'unix': 'npm install',
    "\ 'cygwin': 'npm install',
    "\ 'windows': 'npm install',
    "\ },
    "\ })
    call s:lazyadd('pangloss/vim-javascript', {'autoload':{'filetypes':['javascript']}})
    call s:lazyadd('maksimr/vim-jsbeautify', {'autoload':{'filetypes':['javascript']}})
    nnoremap <leader>fjs :call JsBeautify()<cr>
    call s:lazyadd('leafgarland/typescript-vim', {'autoload':{'filetypes':['typescript']}})
    call s:lazyadd('kchmck/vim-coffee-script', {'autoload':{'filetypes':['coffee']}})
    call s:lazyadd('mmalecki/vim-node.js', {'autoload':{'filetypes':['javascript']}})
    call s:lazyadd('leshill/vim-json', {'autoload':{'filetypes':['javascript','json']}})
    call s:lazyadd('othree/javascript-libraries-syntax.vim', {'autoload':{'filetypes':['javascript','coffee','ls','typescript']}})

    call s:add('artur-shaik/vim-javacomplete2')
    let g:JavaComplete_UseFQN = 1
    let g:JavaComplete_ServerAutoShutdownTime = 300
    let g:JavaComplete_MavenRepositoryDisable = 0
    call s:add('wsdjeg/vim-dict')
    call s:add('wsdjeg/java_getset.vim')
    if s:tap('java_getset.vim')
        let s:hooks = s:get_hooks('java_getset.vim')
        function! s:hooks.on_source(bundle)
            let g:java_getset_disable_map = 1
        endfunction
    endif
    call s:add('wsdjeg/JavaUnit.vim')
    call s:add('jaxbot/github-issues.vim',{'on_cmd' : 'Gissues'})
    call s:add('wsdjeg/Mysql.vim')
    call s:add('vim-jp/vim-java')
    call s:add('vim-airline/vim-airline')
    call s:add('vim-airline/vim-airline-themes')
    let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#tmuxline#enabled = 1
    if s:tap('vim-airline')
        let s:hooks = s:get_hooks('bling/vim-airline')
        function! s:hooks.on_source(bundle)
            let g:Powerline_sybols = 'unicode'
            set statusline+=%#warningmsg#
            set statusline+=%{SyntasticStatuslineFlag()}
            set statusline+=%*
        endfunction
    endif
    call s:add('mattn/emmet-vim')
    let g:user_emmet_install_global = 0
    let g:user_emmet_leader_key='<C-e>'
    let g:user_emmet_mode='a'
    let g:user_emmet_settings = {
                \  'jsp' : {
                \      'extends' : 'html',
                \  },
                \}
    " use this two command to find how long the plugin take!
    "profile start vim-javacomplete2.log
    "profile! file */vim-javacomplete2/*
    if has('nvim') && g:settings.enable_neomake
        call s:add('wsdjeg/neomake')
        if s:tap('neomake')
            let s:hooks = s:get_hooks('neomake')
            function! s:hooks.on_source(bundle) abort
                let g:neomake_open_list = 2  " 1 open list and move cursor 2 open list without move cursor
                let g:neomake_verbose = 0
            endfunction
        endif
    else
        call s:add('wsdjeg/syntastic')
    endif
    if !filereadable('pom.xml') && !filereadable('build.gradle') && isdirectory('bin')
        let g:syntastic_java_javac_options = '-d bin'
    endif
    let g:syntastic_java_javac_config_file_enabled = 1
    let g:syntastic_java_javac_delete_output = 0
    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_check_on_open = 0
    let g:syntastic_check_on_wq = 0
    let g:syntastic_error_symbol = '✖'
    let g:syntastic_warning_symbol = '⚠'
    let g:syntastic_warning_symbol = '➤'
    call s:add('syngan/vim-vimlint', {
                \ 'depends' : 'ynkdir/vim-vimlparser'})
    let g:syntastic_vimlint_options = {
                \'EVL102': 1 ,
                \'EVL103': 1 ,
                \'EVL205': 1 ,
                \'EVL105': 1 ,
                \}
    call s:add('ynkdir/vim-vimlparser')
    call s:add('todesking/vint-syntastic')
    "let g:syntastic_vim_checkers = ['vint']
    call s:add('gcmt/wildfire.vim')
    noremap <SPACE> <Plug>(wildfire-fuel)
    vnoremap <C-SPACE> <Plug>(wildfire-water)
    let g:wildfire_objects = ["i'", 'i"', 'i)', 'i]', 'i}', 'ip', 'it']

    call s:add('scrooloose/nerdcommenter')
    call s:add('easymotion/vim-easymotion')
    call s:add('MarcWeber/vim-addon-mw-utils')
    "NeoBundle 'tomtom/tlib_vim'
    call s:add('mhinz/vim-startify')
    call s:add('mhinz/vim-signify')
    let g:signify_disable_by_default = 0
    let g:signify_line_highlight = 0
    call s:add('airblade/vim-rooter')
    let g:rooter_silent_chdir = 1
    call s:add('Yggdroot/indentLine')
    let g:indentLine_color_term = 239
    let g:indentLine_color_gui = '#09AA08'
    let g:indentLine_char = '¦'
    let g:indentLine_concealcursor = 'niv' " (default 'inc')
    let g:indentLine_conceallevel = 2  " (default 2)
    call s:add('godlygeek/tabular')
    call s:add('benizi/vim-automkdir')
    "[c  ]c  jump between prev or next hunk
    call s:add('airblade/vim-gitgutter')
    call s:add('itchyny/calendar.vim')
    "配合fcitx输入框架,在离开插入模式时自动切换到英文,在同一个缓冲区再次进入插入模式时回复到原来的输入状态
    call s:add('lilydjwg/fcitx.vim')
    call s:add('junegunn/goyo.vim')
    function! s:goyo_enter()
        silent !tmux set status off
        set noshowmode
        set noshowcmd
        set scrolloff=999
        Limelight
    endfunction

    function! s:goyo_leave()
        silent !tmux set status on
        set showmode
        set showcmd
        set scrolloff=5
    endfunction

    autocmd! User GoyoEnter nested call <SID>goyo_enter()
    autocmd! User GoyoLeave nested call <SID>goyo_leave()


    "vim Wimdows config
    "NeoBundle 'scrooloose/nerdtree'
    call s:add('tpope/vim-projectionist')
    call s:add('Xuyuanp/nerdtree-git-plugin')
    call s:add('taglist.vim')
    call s:add('ntpeters/vim-better-whitespace')
    call s:add('junegunn/rainbow_parentheses.vim')
    augroup rainbow_lisp
        autocmd!
        autocmd FileType lisp,clojure,scheme,java RainbowParentheses
    augroup END
    let g:rainbow#max_level = 16
    let g:rainbow#pairs = [['(', ')'], ['[', ']'],['{','}']]
    " List of colors that you do not want. ANSI code or #RRGGBB
    let g:rainbow#blacklist = [233, 234]
    call s:add('majutsushi/tagbar')
    let g:tagbar_width=30
    let g:tagbar_left = 1
    let g:NERDTreeWinPos='right'
    let g:NERDTreeWinSize=31
    let g:NERDTreeChDirMode=1
    autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
    if !executable('ctags')
        let g:Tlist_Ctags_Cmd = '/usr/bin/ctags'  "设置ctags执行路径
    endif
    let g:Tlist_Auto_Update=1
    let g:Tlist_Auto_Open =0
    let g:Tlist_Use_Right_Window=1
    let g:Tlist_Show_One_File=0
    let g:Tlist_File_Fold_Auto_Close=1
    let g:Tlist_Exit_OnlyWindow=1
    let g:Tlist_Show_Menu=1
    noremap <silent> <F8> :TlistToggle<CR>
    "noremap <silent> <F3> :NERDTreeToggle<CR>
    noremap <silent> <F3> :VimFiler<CR>
    autocmd FileType nerdtree nnoremap <silent><Space> :call OpenOrCloseNERDTree()<cr>
    noremap <silent> <F2> :TagbarToggle<CR>
    function! OpenOrCloseNERDTree()
        exec "normal A"
    endfunction
    "}}}

    call s:add('wsdjeg/MarkDown.pl')
    call s:add('benjifisher/matchit.zip')
    call s:add('tomasr/molokai')
    call s:add('simnalamburt/vim-mundo')
    nnoremap <silent> <F7> :MundoToggle<CR>
    "call s:add('nerdtree-ack')
    call s:add('L9')
    call s:add('TaskList.vim')
    map <unique> <Leader>td <Plug>TaskList
    call s:add('ianva/vim-youdao-translater')
    vnoremap <silent> <C-l> <Esc>:Ydv<CR>
    nnoremap <silent> <C-l> <Esc>:Ydc<CR>
    noremap <leader>yd :Yde<CR>
    call s:add('elixir-lang/vim-elixir')
    call s:add('tyru/open-browser.vim')
    if s:tap('open-brower.vim')
        let s:hooks = s:get_hooks("open-brower.vim")
        function! s:hooks.on_source(bundle)
            "for open-browser {{{
            " This is my setting.
            let g:netrw_nogx = 1 " disable netrw's gx mapping.
            "nmap gx <Plug>(openbrowser-smart-search)
            "vmap gx <Plug>(openbrowser-smart-search)
            "" Open URI under cursor.
            nnoremap go <Plug>(openbrowser-open)
            "" Open selected URI.
            vnoremap go <Plug>(openbrowser-open)
            " Search word under cursor.
            nnoremap gs <Plug>(openbrowser-search)
            " Search selected word.
            vnoremap gs <Plug>(openbrowser-search)
            " If it looks like URI, Open URI under cursor.
            " Otherwise, Search word under cursor.
            nnoremap gx <Plug>(openbrowser-smart-search)
            " If it looks like URI, Open selected URI.
            " Otherwise, Search selected word.
            vnoremap gx <Plug>(openbrowser-smart-search)
            vnoremap gob :OpenBrowser http://www.baidu.com/s?wd=<C-R>=expand("<cword>")<cr><cr>
            nnoremap gob :OpenBrowser http://www.baidu.com/s?wd=<C-R>=expand("<cword>")<cr><cr>
            vnoremap gog :OpenBrowser http://www.google.com/?#newwindow=1&q=<C-R>=expand("<cword>")<cr><cr>
            nnoremap gog :OpenBrowser http://www.google.com/?#newwindow=1&q=<C-R>=expand("<cword>")<cr><cr>
            vnoremap goi :OpenBrowserSmartSearch http://www.iciba.com/<C-R>=expand("<cword>")<cr><cr>
            nnoremap goi :OpenBrowserSmartSearch http://www.iciba.com/<C-R>=expand("<cword>")<cr><cr>
            " In command-line
            ":OpenBrowser http://google.com/
            ":OpenBrowserSearch ggrks
            ":OpenBrowserSmartSearch http://google.com/
            ":OpenBrowserSmartSearch ggrks
            "}}}
        endf
    endif
    call s:end()
endif
filetype plugin indent on
syntax on
"}}}
if count(g:settings.plugin_groups, 'colorscheme')&&g:settings.colorscheme!='' "{{{
    set background=dark
    if g:settings.colorscheme!='' && g:settings.neobundle_installed
        exec 'colorscheme '. g:settings.colorscheme
    else
        exec 'colorscheme '. g:settings.colorscheme_default
    endif
endif

let s:My_vimrc = expand('<sfile>')
function! EditMy_virmc()
    exec "edit ".s:My_vimrc
endf

" source basic setting
call s:source_script('general.vim')

if g:settings.enable_cursorline == 1
    set cursorline                  "显示当前行
endif
if g:settings.enable_cursorcolumn == 1
    set cursorcolumn                "显示当前列
endif

"for vim-fasd.vim
nnoremap <Leader>z :Z<CR>

"for ctrlp-z
let g:ctrlp_z_nerdtree = 1
let g:ctrlp_extensions = ['Z', 'F']
nnoremap sz :CtrlPZ<Cr>
nnoremap sf :CtrlPF<Cr>

call s:source_script('functions.vim')




call s:source_script('mappings.vim')

"background
noremap <silent><leader>bg :call ToggleBG()<CR>
"numbers
noremap <silent><leader>nu :call ToggleNumber()<CR>

call s:source_script('autocmds.vim')

"functions
"{{{
autocmd FileType python,coffee call s:check_if_expand_tab()
autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
    " Overwrite settings.

    " Play nice with supertab
    let b:SuperTabDisabled=1
    " Enable navigation with control-j and control-k in insert mode
    imap <buffer> <C-n>   <Plug>(unite_select_next_line)
    nmap <buffer> <C-n>   <Plug>(unite_select_next_line)
    imap <buffer> <C-p>   <Plug>(unite_select_previous_line)
    nmap <buffer> <C-p>   <Plug>(unite_select_previous_line)


    imap <buffer> jj      <Plug>(unite_insert_leave)
    "imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)

    imap <buffer><expr> j unite#smart_map('j', '')
    imap <buffer> <TAB>   <Plug>(unite_select_next_line)
    imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)
    imap <buffer> '     <Plug>(unite_quick_match_default_action)
    nmap <buffer> '     <Plug>(unite_quick_match_default_action)
    imap <buffer><expr> x
                \ unite#smart_map('x', "\<Plug>(unite_quick_match_choose_action)")
    nmap <buffer> x     <Plug>(unite_quick_match_choose_action)
    nmap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-y>     <Plug>(unite_narrowing_path)
    nmap <buffer> <C-y>     <Plug>(unite_narrowing_path)
    nmap <buffer> <C-e>     <Plug>(unite_toggle_auto_preview)
    imap <buffer> <C-e>     <Plug>(unite_toggle_auto_preview)
    nmap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
    imap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
    nnoremap <silent><buffer><expr> l
                \ unite#smart_map('l', unite#do_action('default'))

    let unite = unite#get_current_unite()
    if unite.profile_name ==# 'search'
        nnoremap <silent><buffer><expr> r     unite#do_action('replace')
    else
        nnoremap <silent><buffer><expr> r     unite#do_action('rename')
    endif

    nnoremap <silent><buffer><expr> cd     unite#do_action('lcd')
    nnoremap <buffer><expr> S      unite#mappings#set_current_filters(
                \ empty(unite#mappings#get_current_filters()) ?
                \ ['sorter_reverse'] : [])

    " Runs "split" action by <C-s>.
    imap <silent><buffer><expr> <C-s>     unite#do_action('split')
endfunction
function! s:check_if_expand_tab()
    let has_noexpandtab = search('^\t','wn')
    let has_expandtab = search('^    ','wn')

    "
    if has_noexpandtab && has_expandtab
        let idx = inputlist ( ['ERROR: current file exists both expand and noexpand TAB, python can only use one of these two mode in one file.\nSelect Tab Expand Type:',
                    \ '1. expand (tab=space, recommended)',
                    \ '2. noexpand (tab=\t, currently have risk)',
                    \ '3. do nothing (I will handle it by myself)'])
        let tab_space = printf('%*s',&tabstop,'')
        if idx == 1
            let has_noexpandtab = 0
            let has_expandtab = 1
            silent exec '%s/\t/' . tab_space . '/g'
        elseif idx == 2
            let has_noexpandtab = 1
            let has_expandtab = 0
            silent exec '%s/' . tab_space . '/\t/g'
        else
            return
        endif
    endif

    "
    if has_noexpandtab == 1 && has_expandtab == 0
        echomsg 'substitute space to TAB...'
        set noexpandtab
        echomsg 'done!'
    elseif has_noexpandtab == 0 && has_expandtab == 1
        echomsg 'substitute TAB to space...'
        set expandtab
        echomsg 'done!'
    else
        " it may be a new file
        " we use original vim setting
    endif
endfunction

function! MyTagfunc() abort
    mark H
    let s:MyTagfunc_flag = 1
    UniteWithCursorWord -immediately tag
endfunction

function! MyTagfuncBack() abort
    if exists('s:MyTagfunc_flag')&&s:MyTagfunc_flag
        exe "normal! `H"
        let s:MyTagfunc_flag =0
    endif
endfunction

function! MyEnterfunc() abort
    if pumvisible()
        if getline('.')[col('.') - 2]=="{"
            return "\<Enter>"
        elseif g:settings.autocomplete_method == 'neocomplete'||g:settings.autocomplete_method == 'deoplete'
            return "\<C-y>"
        else
            return "\<esc>a"
        endif
    elseif getline('.')[col('.') - 2]=="{"&&getline('.')[col('.')-1]=="}"
        return "\<Enter>\<esc>ko"
    else
        return "\<Enter>"
    endif
endf

function! MyLeaderTabfunc() abort
    if g:settings.autocomplete_method == 'deoplete'
        return deoplete#mappings#manual_complete(['omni'])
    elseif g:settings.autocomplete_method == 'neocomplete'
        return neocomplete#start_manual_complete(['omni'])
    endif
endfunction

function! MyTabfunc() abort
    if getline('.')[col('.')-2] =='{'&& pumvisible()
        return "\<C-n>"
    endif
    if neosnippet#expandable() && getline('.')[col('.')-2] =='(' && !pumvisible()
        return "\<Plug>(neosnippet_expand)"
    elseif neosnippet#jumpable() && getline('.')[col('.')-2] =='(' && !pumvisible() && !neosnippet#expandable()
        return "\<plug>(neosnippet_jump)"
    elseif neosnippet#expandable_or_jumpable() && getline('.')[col('.')-2] !='('
        return "\<plug>(neosnippet_expand_or_jump)"
    elseif pumvisible()
        return "\<C-n>"
    else
        return "\<tab>"
    endif
endfunction



if filereadable(expand('~/.config/nvim/autoload/plug.vim'))
    call plug#begin('~/.cache/vim-plug')
    Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
    Plug 'junegunn/gv.vim'
    "for fzf
    nnoremap <Leader>fz :FZF<CR>
    if !has('nvim')
        Plug 'junegunn/vim-github-dashboard'
    endif
    call plug#end()
endif


"============> plug.vim
set mouse=
set hidden
if has('nvim')
    augroup Terminal
        au!
        au TermOpen * let g:last_terminal_job_id = b:terminal_job_id
        au WinEnter term://* startinsert
    augroup END
    if g:settings.enable_neomake
        augroup Neomake_wsd
            au!
            autocmd! BufWritePost * Neomake
        augroup END
    endif
    call s:source_script('neovim.vim')
endif

func! Openpluginrepo()
    try
        exec "normal! ".'"ayi'."'"
        exec 'OpenBrowser https://github.com/'.@a
    catch
        echohl WarningMsg | echomsg "can not open the web of current plugin" | echohl None
    endtry
endf

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.  Only define it when not
" defined already.
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
            \ | wincmd p | diffthis
" }}}
